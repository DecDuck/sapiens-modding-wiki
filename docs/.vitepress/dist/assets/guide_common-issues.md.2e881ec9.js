import{_ as e,c as s,o,a as n}from"./app.799f5912.js";const m=JSON.parse('{"title":"Common Issues","description":"","frontmatter":{},"headers":[{"level":2,"title":"Confusing module.function with module:function","slug":"confusing-module-function-with-module-function"},{"level":2,"title":"Recursive mjrequire","slug":"recursive-mjrequire"}],"relativePath":"guide/common-issues.md","lastUpdated":1658674797000}'),a={name:"guide/common-issues.md"},l=n(`<h1 id="common-issues" tabindex="-1">Common Issues <a class="header-anchor" href="#common-issues" aria-hidden="true">#</a></h1><p>This page covers a few common issues that you may face, when developing mods for Sapiens.</p><h2 id="confusing-module-function-with-module-function" tabindex="-1">Confusing module.function with module:function <a class="header-anchor" href="#confusing-module-function-with-module-function" aria-hidden="true">#</a></h2><p>In lua, you define a module like <code>local foo = {}</code>. Functions can then be defined like:</p><div class="language-lua"><span class="copy"></span><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">foo</span><span style="color:#A6ACCD;">:</span><span style="color:#82AAFF;">bar</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">arg1</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">end</span></span>
<span class="line"></span></code></pre></div><p>This is a shorthand for the longer form (don&#39;t use this except for shadows)</p><div class="language-lua"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">foo.bar </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> arg1</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">end</span></span>
<span class="line"></span></code></pre></div><p>As you can see, there is a mysterious &#39;self&#39; argument getting passed around when using the <code>:</code> syntax. This roughly represents the current object (?).</p><p>Now imagine that you&#39;ve defined a function as in the first example, and then attempted to call it like this:</p><p><code>local value = foo.bar(&#39;baz&#39;)</code></p><p>This would be incorrect, since you&#39;ve essentially put &#39;baz&#39; for &#39;self&#39; and &#39;nil&#39; for &#39;arg1&#39;. The correct way to call it would be <code>local value = foo:bar(&#39;baz&#39;)</code>.</p><h2 id="recursive-mjrequire" tabindex="-1">Recursive mjrequire <a class="header-anchor" href="#recursive-mjrequire" aria-hidden="true">#</a></h2><p>If you have <code>foo.lua</code> which requires <code>bar.lua</code>, then you can&#39;t require <code>bar.lua</code> in <code>foo.lua</code> because it would cause an infinite loop.</p><p>Workarounds:</p><ul><li>mjrequire inside of Functions</li><li>rework your architecture</li><li>pass <code>bar</code> as a parameter to <code>foo</code> (init function)</li></ul>`,15),t=[l];function c(i,r,p,u,d,f){return o(),s("div",null,t)}var y=e(a,[["render",c]]);export{m as __pageData,y as default};
