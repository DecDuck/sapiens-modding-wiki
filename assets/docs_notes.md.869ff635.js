import{_ as e,c as a,o as t,a as i}from"./app.4c03ac92.js";const f=JSON.parse('{"title":"GOM","description":"","frontmatter":{},"headers":[{"level":3,"title":"GOM","slug":"gom"},{"level":3,"title":"Thread Communication","slug":"thread-communication"},{"level":3,"title":"Call Server Function","slug":"call-server-function"},{"level":3,"title":"Materials","slug":"materials"},{"level":3,"title":"Shadowing and Threading","slug":"shadowing-and-threading"}],"relativePath":"docs/notes.md","lastUpdated":1655090296000}'),n={name:"docs/notes.md"},o=i('<h3 id="gom" tabindex="-1">GOM <a class="header-anchor" href="#gom" aria-hidden="true">#</a></h3><p>Oh GOM stands for GameObjectManager just in case that isn&#39;t obvious. I got sick of typing it everywhere</p><h3 id="thread-communication" tabindex="-1">Thread Communication <a class="header-anchor" href="#thread-communication" aria-hidden="true">#</a></h3><p>The only supported way to communicate between threads is the callMainThreadFunction/registerMainThreadFunction types of methods. just note too that the lua objects need to be serialized/unserialized when those methods are called, and that can be a performance bottleneck if abused too much</p><h3 id="call-server-function" tabindex="-1">Call Server Function <a class="header-anchor" href="#call-server-function" aria-hidden="true">#</a></h3><p>you can only pass one arg to callServerFunction. Pass a table if you need more.</p><p>all regsitered server functions get given the clientID and arg</p><h3 id="materials" tabindex="-1">Materials <a class="header-anchor" href="#materials" aria-hidden="true">#</a></h3><p>Black shiny stuff means it cant find a material in material.lua that matches what is specified in the model</p><h3 id="shadowing-and-threading" tabindex="-1">Shadowing and Threading <a class="header-anchor" href="#shadowing-and-threading" aria-hidden="true">#</a></h3><p>Basically when the script is loaded, it is run. So when you declare that mod:onLoad function it is the same as saying mod.onLoad = function(self). You can do whatever you like there, and quite a few vanilla scripts do set up various state at that base level. I do kind of try to avoid it though, as you can&#39;t assume everything has been fully loaded at that point.</p><p>I&#39;m not sure how you plan on structuring this for the multiple threads? buildable:addBuildable will need to be called from all, so if you do it this way without shadowing buildable, or solving it some other way, you&#39;ll need to do it in 3 places, instead of one.</p>',12),s=[o];function r(d,l,h,c,u,m){return t(),a("div",null,s)}var g=e(n,[["render",r]]);export{f as __pageData,g as default};
